module.exports = function (contexts, tbeSchemas, Battle) {
    "use strict";

    var q = require("q"),
        BattleModel = tbeSchemas.schema.Battle.newModel(),
        //BattleModel = require("../tbe/loader").schema.Battle.model,
        fetchBattle = function (cb) {
            BattleModel.findOne({}, function (err, battle) {
                cb(err, battle);
            });
        },
        bc = { };

    bc.start = function (contextName, battleFactoryName, player_id, success, error) {
        // Validate battleFactoryName and player_id.
        // Ensure that there is no existing battle first. Find a good place to request the existence of a battle.
        // Get context
        // Get battle factory
        var context = contexts[contextName],
            battleFactory = context.getBattleFactory(battleFactoryName),
            response = { };

        fetchBattle(function (err, battleModel) {
            if (!battleModel) {
                // No current battle
                // Generate battle
                response.status = "new";
                // Ultimately this will require details of the player, but for now we're just going to create the battle.
                battleModel = battleFactory.generate().getModel();
                // Save battle
                battleModel.save(function (err) {
                    if (err) {
                        response.err = err;
                        error(response);
                    } else {
                        success(response);
                    }
                });
            } else {
                reponse.status = "in-progress";
                success(response);
            }
        });

        // If valid, return 200. If invalid, return appropriate code.
        return { };
    };
    bc.get = function (player_id, success, error) {
        // Player can only be in one battle at a time, so check it.
        // Get battle state.
        // Also try to return a delta - showing changes. 
        // This would make it easier for the front-end to animate changes,
            // rather than reverse engineering.
        var abilities = contexts["space-intel"].abilities();
        // Todo: List of abilities must be limited to those available to the player.
        // The player has characters generated by the battle factory.
        // The battle factory should only run to trigger the beginning of a battle.
        // The characters are generated with specific abilities.
        success({
            abilities: abilities
        });
    };
    bc.ability = function (playerId, abilityName, queryData) {
        // queryData must be considered unsanitised and potentially dangerous
        // at this point.
        var deferred = q.defer(),
            reject = false,
            error = {type: "unknown"},
            ability = contexts["space-intel"].ability(abilityName),
            available = contexts["space-intel"].abilityAvailable(abilityName); // Check if available to playerId.

        if (ability) {
            // Check if ability is available to playerId
            if (available) {
                // Run ability with queryData
                if (ability.run(queryData)) {
                    deferred.resolve();
                    // Also need to return an error if the ability 
                    // cannot be cast according to the game logic.
                } else {
                    reject = true;
                    error.type = "malformed";
                    error.query = { }; // Based on missing queryData.
                }
            } else {
                reject = true;
                error.type = "unavailable";
            }
        } else {
            reject = true;
            error.type = "nonexistent";
        }

        if (reject) {
            deferred.reject(error);
        }

        return deferred.promise;
    };

    return bc;
};
