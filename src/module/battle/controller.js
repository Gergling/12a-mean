module.exports = (function () {
//module.exports = function (contexts, tbeSchemas, Battle) {
    "use strict";

    var q = require("q"),
        contexts = require("../application/loader/contexts"),
        BattleModel = require('../tbe/schema').Battle.newModel(),
        fetchBattle = function (cb) {
            BattleModel.findOne({}, function (err, battle) {
                cb(err, battle);
            });
        },
        bc = { };

    /*jslint unparam: true */
    bc.start = function (
        contextName,
        battleFactoryName,
        playerId,
        success,
        error
    ) {
        // Validate battleFactoryName and player_id.
        // Ensure that there is no existing battle first. 
        // Find a good place to request the existence of a battle.
        // Get context
        // Get battle factory
        var context = contexts[contextName],
            battleFactory = context.getBattleFactory(battleFactoryName),
            response = { };

        fetchBattle(function (err, battleModel) {
            if (!battleModel) {
                // No current battle
                // Generate battle
                response.status = "new";
                // Ultimately this will require details of the player, 
                // but for now we're just going to create the battle.
                battleModel = battleFactory.generate().getModel();
                // Save battle
                battleModel.save(function (err) {
                    if (err) {
                        response.err = err;
                        error(response);
                    } else {
                        success(response);
                    }
                });
            } else {
                response.status = "in-progress";
                success(response);
            }
        });

        // If valid, return 200. If invalid, return appropriate code.
        return { };
    };
    /*jslint unparam: false */

    /*jslint unparam: true */
    bc.current = function (req, res) {
        var player_id = 1,
            abilities;

        if (player_id) {
            // Player can only be in one battle at a time, so check it.
            // Get battle state.
            // Also try to return a delta - showing changes. 
            // This would make it easier for the front-end to animate changes,
                // rather than reverse engineering.
            abilities = contexts["space-intel"].abilities();
            // List of abilities must be limited to those available to 
                // the player.
            // The player has characters generated by the battle factory.
            // The battle factory should only run to trigger the beginning 
                // of a battle.
            // The characters are generated with specific abilities.
            res.send({
                abilities: abilities
            });

            // If error:
            //res.send(err);
            //res.status(500).end();
        } else {
            res.send();
            res.status(403).end();
        }
    };
    /*jslint unparam: false */

    bc.turn = function (req, res) {
        res.send(req);
    };

    bc.cast = function (req, res) {
        var player_id = 1;
        if (player_id) {
            bc.ability(
                player_id,
                req.params.abilityName,
                req.query // Controller to sanitise.
            ).then(function () {
                res.send({ });
            }, function (error) {
                switch (error.type) {
                case "malformed":
                    res.status(400).send(error.query);
                    break;
                case "unavailable":
                    res.status(403).end();
                    break;
                case "nonexistent":
                    res.status(404).end();
                    break;
                default:
                    res.status(500).end();
                }
            });
        } else {
            res.status(401).end();
        }
    };
    bc.ability = function (playerId, abilityName, queryData) {
        // queryData must be considered unsanitised and potentially dangerous
        // at this point.
        var deferred = q.defer(),
            reject = false,
            error = { type: "unknown" },
            ability = contexts["space-intel"].ability(abilityName),
            available = contexts["space-intel"].abilityAvailable(abilityName);

        // Check if available to playerId.
        // Restructure might be useful.
        // Submit a list of functions to be run in order against the error types.
        [
            [ "notallowed", function () {return playerId; } ],
            [ "nonexistent", function () {return ability; } ],
            [ "unavailable", function () {return available; } ]
        ].forEach(function (validation) {
            var errorType = validation[0],
                fnc = validation[1];

            if (!fnc()) {
                reject = true;
                error.type = errorType;
            }
        });

        if (!reject && ability.run(queryData)) {
            reject = false;
            deferred.resolve();
            // Also need to return an error if the ability 
            // cannot be cast according to the game logic.
        } else {
            error.type = "malformed";
            error.query = { }; // Based on missing queryData.
        }

        /*if (playerId) {
            if (ability) {
                // Check if ability is available to playerId
                if (available) {
                    // Run ability with queryData
                    if (ability.run(queryData)) {
                        reject = false;
                        deferred.resolve();
                        // Also need to return an error if the ability 
                        // cannot be cast according to the game logic.
                    } else {
                        error.type = "malformed";
                        error.query = { }; // Based on missing queryData.
                    }
                } else {
                    error.type = "unavailable";
                }
            } else {
                error.type = "nonexistent";
            }
        } else {
            error.type = "notallowed";
        }*/

        if (reject) {
            deferred.reject(error);
        }

        return deferred.promise;
    };

    return bc;
}());
